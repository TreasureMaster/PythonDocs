# open \(\)

### open \( _file_, _mode='r'_, _buffering=-1_, _encoding=None_, _errors=None_, _newline=None_, _closefd=True_, _opener=None_ \)

Открывает файл _**file**_ и возвращает соответствующий файловый объект. Если файл не открывается, возникает ошибка OSError. См. дополнительные примеры использования этой функции в разделе «Чтение и запись файлов».

_**file**_ - это объект, похожий на путь, задающий имя пути \(абсолютное или относительное к текущему рабочему каталогу\) открываемого файла или целочисленный файловый дескриптор файла, который нужно обернуть. \(Если указан файловый дескриптор, он закрывается при закрытии возвращенного объекта ввода-вывода, если для _**closefd**_ не задано значение `False`.\)

_**mode**_ - необязательная строка, указывающая режим, в котором открывается файл. По умолчанию это `'r'`, что означает открытие для чтения в текстовом режиме. Другими распространенными значениями являются `'w'` для записи \(удаляет содержимое файла, если он уже существует\), `'x'` для исключительного создания и `'a'` для добавления \(что в некоторых системах Unix означает, что все записи добавляются в конец файла независимо от текущей позиции поиска\). В текстовом режиме, если кодировка не указана, используемая кодировка зависит от платформы: `locale.getpreferredencoding (False)` вызывается для получения текущей кодировки языкового стандарта. \(Для чтения и записи сырых байтов используйте двоичный режим и не указывайте кодировку.\) Доступны следующие режимы:

| Символ _**mode**_ | Значение |
| :--- | :--- |
| `'r'` | открыть для чтения \(по умолчанию\) |
| `'w'` | открыть для записи, удалить содержимое файла |
| `'x'` | открыть для монопольного создания, сбой, если файл уже существует |
| `'a'` | открыть для записи, добавить в конец файла, если он существует |
| `'b'` | двоичный режим |
| `'t'` | текстовый режим \(по умолчанию\) |
| `'+'` | открыть для обновления \(чтение и запись\) |

Режим по умолчанию - `'r'` \(открыть для чтения текста, синоним `'rt'`\). Режимы `'w+'` и `'w+b'` открывают и обрезают файл. Режимы `'r +'` и `'r+b'` открывают файл без усечения.

Как упоминалось в обзоре, Python различает двоичный и текстовый ввод-вывод. Файлы, открытые в двоичном режиме \(включают аргумент `'b'` режима\), возвращают содержимое как байтовые объекты без какого-либо декодирования. В текстовом режиме \(по умолчанию или когда включен аргумент режима `'t'`\) содержимое файла возвращается как строка **str**, байты были сначала декодированы с использованием зависящей от платформы кодировки или с использованием указанной кодировки _**encoding**_, если она задана.

Разрешен дополнительный символ режима `'U'`, который больше не действует и считается устаревшим. Ранее он включал универсальные символы новой строки в текстовом режиме, который стал поведением по умолчанию в Python 3.0. Обратитесь к документации параметра новой строки для получения дополнительных сведений.

{% hint style="info" %}
Python не зависит от представления текстовых файлов базовой операционной системой; вся обработка выполняется самим Python и поэтому не зависит от платформы.
{% endhint %}

_**buffering**_ - необязательное целое число, используемое для установки политики буферизации. Передайте 0, чтобы отключить буферизацию \(разрешено только в двоичном режиме\), 1, чтобы выбрать построчную буферизацию \(можно использовать только в текстовом режиме\), и целое число &gt; 1, чтобы указать размер в байтах буфера фрагментов фиксированного размера. Если аргумент _**buffering**_ не указан, политика буферизации по умолчанию работает следующим образом:

* двоичные файлы буферизуются кусками фиксированного размера; размер буфера выбирается с помощью эвристики, пытающейся определить «размер блока» нижележащего устройства и возвращаясь к io.DEFAULT\_BUFFER\_SIZE. Во многих системах размер буфера обычно составляет 4096 или 8192 байта.
* «интерактивные» текстовые файлы \(файлы, для которых [isatty \(\)](../obshie-sluzhby-operacionnoi-sistemy/io/io.iobase/io.iobase.isatty.md) возвращает `True`\) используют буферизацию строк. Другие текстовые файлы используют политику, описанную выше для двоичных файлов.

