# os.rename \(\)

### os.rename \( _src_, _dst_, _\*_, _src\_dir\_fd=None_, _dst\_dir\_fd=None_ \)

Переименовывает файл или каталог _**src**_ в _**dst**_. Если _**dst**_ существует, операция завершится ошибкой с подклассом OSError в ряде случаев:

В Windows, если существует _**dst**_, всегда возникает FileExistsError.

В Unix, если _**src**_ - это файл, а _**dst**_ - это каталог, или наоборот, соответственно будет возникать IsADirectoryError или NotADirectoryError. Если оба являются каталогами и _**dst**_ пуст, _**dst**_ будет автоматически заменен. Если _**dst**_ - непустой каталог, возникает ошибка OSError. Если оба являются файлами, _**dst**_ будет заменен автоматически, если у пользователя есть разрешение. Операция может завершиться ошибкой в некоторых версиях Unix, если _**src**_ и _**dst**_ находятся в разных файловых системах. В случае успеха переименование будет атомарной операцией \(это требование POSIX\).

Эта функция может поддерживать указание _**src\_dir\_fd**_ и/или _**dst\_dir\_fd**_ для предоставления путей относительно дескрипторов каталогов.

Если вы хотите кросс-платформенную перезапись места назначения, используйте [replace \(\)](os.replace.md).

Вызывает событие аудита **os.rename** с аргументами `src`, `dst`, `src_dir_fd`, `dst_dir_fd`.

_Новое в версии 3.3:_ аргументы _**src\_dir\_fd**_ и _**dst\_dir\_fd**_.

_Изменено в версии 3.6:_ принимает объект, подобный пути \(_path-like object_ \), для _**src**_ и _**dst**_.

