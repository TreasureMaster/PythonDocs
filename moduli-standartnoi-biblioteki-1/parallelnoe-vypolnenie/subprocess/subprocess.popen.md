# subprocess.Popen

#### _class_ subprocess.Popen \( _args_, _bufsize=-1_, _executable=None_, _stdin=None_, _stdout=None_, _stderr=None_, _preexec\_fn=None_, _close\_fds=True_, _shell=False_, _cwd=None_, _env=None_, _universal\_newlines=None_, _startupinfo=None_, _creationflags=0_, _restore\_signals=True_, _start\_new\_session=False_, _pass\_fds=\(\)_, _\*_, _encoding=None_, _errors=None_, _text=None_ \)

Выполняет дочернюю программу в новом процессе. В POSIX класс использует поведение, подобное os.execvp \(\), для выполнения дочерней программы. В Windows класс использует функцию Windows CreateProcess \(\). Аргументы класса **Popen** следующие:

_**args**_ должен быть последовательностью аргументов программы или отдельной строкой или объектом, подобным пути \(_path-like object_ \). По умолчанию программа для выполнения является первым элементом в _**args**_, если args является последовательностью. Если _**args**_ является строкой, интерпретация зависит от платформы и описана ниже. См. аргументы _**shell**_ и _**executable**_, чтобы узнать о дополнительных отличиях от поведения по умолчанию. Если не указано иное, рекомендуется передавать аргументы в виде последовательности.

Пример передачи некоторых аргументов внешней программе в виде последовательности:

```python
Popen(["/usr/bin/git", "commit", "-m", "Fixes a bug."])
```

В POSIX, если _**args**_ является строкой, строка интерпретируется как имя или путь выполняемой программы. Однако это можно сделать, только если не передать аргументы программе.

{% hint style="info" %}
**Примечание:** Может быть неочевидно, как разбить команду оболочки на последовательность аргументов, особенно в сложных случаях. `shlex.split ()` может проиллюстрировать, как определить правильную токенизацию для _**args**_:

```python
>>> import shlex, subprocess
>>> command_line = input()
/bin/vikings -input eggs.txt -output "spam spam.txt" -cmd "echo '$MONEY'"
>>> args = shlex.split(command_line)
>>> print(args)
['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', "echo '$MONEY'"]
>>> p = subprocess.Popen(args) # Success!
```

Обратите внимание, в частности, что параметры \(такие как _-input_ \) и аргументы \(например, _egg.txt_ \), разделенные пробелом в оболочке, помещаются в отдельные элементы списка, в то время как аргументы, требующие кавычек или экранирования обратной косой черты при использовании в оболочке \(например, имена файлов, содержащие пробелы или показанную выше команду _echo_ \) являются отдельными элементами списка.
{% endhint %}

В Windows, если _**args**_ является последовательностью, она будет преобразована в строку способом, описанным в разделе «Преобразование последовательности аргументов в строку в Windows». Это связано с тем, что базовый `CreateProcess ()` работает со строками.

_Изменено в версии 3.6:_ параметр _**args**_ принимает объект, подобный пути \(_path-like object_ \), если оболочка имеет значение `False`, и последовательность, содержащую объекты, подобные пути \(_path-like object_ \), в POSIX.

_Изменено в версии 3.8:_ параметр _**args**_ принимает объект, подобный пути \(_path-like object_ \), если оболочка имеет значение `False`, и последовательность, содержащую байты и объекты, подобные пути \(_path-like object_ \), в Windows.

Аргумент _**shell**_ \(по умолчанию `False`\) указывает, следует ли использовать оболочку в качестве программы для выполнения. Если _**shell**_ имеет значение `True`, рекомендуется передавать аргументы в виде строки, а не последовательности.

В POSIX с `shell = True` для оболочки по умолчанию используется `/bin/sh`. Если _**args**_ является строкой, строка указывает команду, выполняемую через оболочку. Это означает, что строка должна быть отформатирована точно так же, как при вводе в приглашении оболочки. Это включает, например, кавычки или обратную косую черту, экранирующие имена файлов с пробелами. Если _**args**_ представляет собой последовательность, первый элемент определяет командную строку, а любые дополнительные элементы будут обрабатываться как дополнительные аргументы самой оболочки. То есть **Popen** выполняет эквивалент:

```python
Popen(['/bin/sh', '-c', args[0], args[1], ...])
```

В Windows с `shell = True` переменная среды COMSPEC указывает оболочку по умолчанию. Единственный раз, когда вам нужно указать `shell = True` в Windows, - это когда команда, которую вы хотите выполнить, встроена в оболочку \(например, dir или copy\). `shell = True` не требуется для запуска командного файла или исполняемого файла на основе консоли.

{% hint style="info" %}
**Примечание:** прочтите раздел «Вопросы безопасности» перед использованием `shell = True`.
{% endhint %}

_**bufsize**_ будет предоставлен в качестве соответствующего аргумента функции open \(\) при создании файловых объектов [stdin](popen.stdin.md) / [stdout](popen.stdout.md) / [stderr](popen.stderr.md) pipe:

* **0** - означает небуферизованный \(чтение и запись являются одним системным вызовом и могут возвращаться коротко\)
* **1** - означает буферизацию строки \(можно использовать, только если `universal_newlines = True`, т.е. в текстовом режиме\)
* любое другое положительное значение означает использование буфера примерно такого размера
* отрицательный _**bufsize**_ \(по умолчанию\) означает, что будет использоваться системное значение по умолчанию io.DEFAULT\_BUFFER\_SIZE

_Изменено в версии 3.3.1:_ теперь _**bufsize**_ по умолчанию равен **-1**, чтобы по умолчанию включить буферизацию в соответствии с поведением, ожидаемым большинством кода. В версиях, предшествующих Python 3.2.4 и 3.3.1, по умолчанию было неправильно установлено значение 0, которое не буферизовалось и позволяло короткие чтения. Это было непреднамеренно и не соответствовало поведению Python 2, как ожидалось в большинстве программ.

Аргумент _**executable**_ указывает программу замены, которую нужно выполнить. Это очень редко нужно. Когда `shell = False`, исполняемый файл заменяет программу на выполнение, указанную в _**args**_. Однако исходные аргументы по-прежнему передаются программе. Большинство программ рассматривают программу, указанную аргументом _**args**_, как имя команды, которое в таком случае может отличаться от фактически выполняемой программы. В POSIX имя _**args**_ становится отображаемым именем исполняемого файла в таких утилитах, как **ps**. Если `shell = True`, в POSIX исполняемый аргумент указывает заменяющую оболочку для значения по умолчанию `/bin/sh`.

_Изменено в версии 3.6:_ параметр _**executable**_ принимает объект, подобный пути \(_path-like object_ \), в POSIX.

_Изменено в версии 3.8:_ параметр _**executable**_ принимает байты и объект, подобный пути \(_path-like object_ \) в Windows.

_\*\*\*\*_[_**stdin**_](popen.stdin.md), [_**stdout**_](popen.stdout.md) и [_**stderr**_](popen.stderr.md) определяют дескрипторы стандартного ввода, стандартного вывода и стандартного файла ошибок исполняемой программы соответственно. Допустимые значения: [PIPE](subprocess.pipe.md), DEVNULL, существующий дескриптор файла \(положительное целое число\), существующий файловый объект и `None`. [PIPE](subprocess.pipe.md) указывает, что должен быть создан новый канал для дочернего элемента. DEVNULL указывает, что будет использоваться специальный файл os.devnull. Если по умолчанию установлено значение `None`, перенаправление не произойдет; дескрипторы дочерних файлов будут унаследованы от родительского. Кроме того, _**stderr**_ может быть STDOUT, что указывает на то, что данные _**stderr**_ из приложений должны быть записаны в тот же дескриптор файла, что и для _**stdout**_.

Если для _**preexec\_fn**_ задан вызываемый объект, этот объект будет вызываться в дочернем процессе непосредственно перед выполнением дочернего процесса. \(Только POSIX\)

{% hint style="danger" %}
Параметр _**preexec\_fn**_ небезопасно использовать при наличии потоков в вашем приложении. Дочерний процесс может зайти в тупик до вызова exec. Если вы должны его использовать, оставьте это тривиальным! Сведите к минимуму количество вызываемых вами библиотек.
{% endhint %}

{% hint style="info" %}
Если вам нужно изменить среду для дочернего объекта, используйте параметр _**env**_ вместо того, чтобы делать это в _**preexec\_fn**_. Параметр _**start\_new\_session**_ может заменить ранее распространенное использование _**preexec\_fn**_ для вызова os.setsid \(\) в дочернем элементе.
{% endhint %}

_Изменено в версии 3.8:_ параметр _**preexec\_fn**_ больше не поддерживается в субинтерпретаторах. Использование параметра в субинтерпретаторе вызывает ошибку RuntimeError. Новое ограничение может повлиять на приложения, развернутые в mod\_wsgi, uWSGI и других встроенных средах.

Если _**close\_fds**_ равно `True`, все файловые дескрипторы, кроме 0, 1 и 2, будут закрыты до выполнения дочернего процесса. В противном случае, когда _**close\_fds**_ имеет значение `False`, файловые дескрипторы подчиняются своему наследуемому флагу, как описано в разделе «Наследование файловых дескрипторов».

В Windows, если _**close\_fds**_ имеет значение `True`, то дескрипторы не будут унаследованы дочерним процессом, если они явно не переданы в элементе `handle_list` файла STARTUPINFO.lpAttributeList или стандартным перенаправлением дескрипторов.

_Изменено в версии 3.2:_ значение по умолчанию для _**close\_fds**_ было изменено с `False` на то, что описано выше.

_Изменено в версии 3.7:_ в Windows значение по умолчанию для _**close\_fds**_ было изменено с `False` на `True` при перенаправлении стандартных дескрипторов. Теперь можно установить _**close\_fds**_ в `True` при перенаправлении стандартных дескрипторов.

_**pass\_fds**_ - это необязательная последовательность файловых дескрипторов, которые должны оставаться открытыми между родительским и дочерним. Предоставление любого _**pass\_fds**_ заставляет _**close\_fds**_ быть `True`. \(Только POSIX\)

_Изменено в версии 3.2:_ Добавлен параметр _**pass\_fds**_.

Если _**cwd**_ не равно `None`, функция изменяет текущий рабочий каталог на _**cwd**_ перед выполнением дочернего элемента. _**cwd**_ может быть строкой, байтами или объектом, подобным пути \(_path-like object_ \). В частности, функция ищет исполняемый файл \(или первый элемент в _**args**_\) относительно _**cwd**_, если путь к исполняемому файлу является относительным.

_Изменено в версии 3.6:_ параметр _**cwd**_ принимает объект, подобный пути \(_path-like object_ \), в POSIX.

_Изменено в версии 3.7:_ параметр _**cwd**_ принимает в Windows объект, похожий на путь \(_path-like object_ \).

_Изменено в версии 3.8:_ параметр _**cwd**_ принимает байтовый объект в Windows.

Если _**restore\_signals**_ имеет значение `True` \(по умолчанию\), все сигналы, которые Python установил в SIG\_IGN, восстанавливаются в SIG\_DFL в дочернем процессе перед exec. В настоящее время это включает сигналы SIGPIPE, SIGXFZ и SIGXFSZ. \(Только POSIX\)

_Изменено в версии 3.2:_ добавлено _**restore\_signals**_.

Если _**start\_new\_session**_ равно `True`, системный вызов setsid \(\) будет выполнен в дочернем процессе до выполнения подпроцесса. \(Только POSIX\)

_Изменено в версии 3.2:_ добавлен _**start\_new\_session**_.

Если _**env**_ не равно `None`, это должно быть отображение, определяющее переменные среды для нового процесса; они используются вместо поведения по умолчанию при наследовании среды текущего процесса.

{% hint style="info" %}
Если указано, _**env**_ должен предоставить все переменные, необходимые для выполнения программы. В Windows для запуска параллельной сборки указанный _**env**_ должен включать действительный SystemRoot.
{% endhint %}

Если указаны _**encoding**_ или _**errors**_, либо _**text**_ имеет значение `True`, файловые объекты [_**stdin**_](popen.stdin.md), [_**stdout**_](popen.stdout.md) и [_**stderr**_](popen.stderr.md) открываются в текстовом режиме с указанной _**encoding**_ и _**errors**_, как описано выше в разделе «Часто используемые аргументы». Аргумент _**universal\_newlines**_ эквивалентен тексту и предоставляется для обратной совместимости. По умолчанию файловые объекты открываются в двоичном режиме.

_Новое в версии 3.6:_ добавлены _**encoding**_ и _**errors**_.

_Новое в версии 3.7:_ _**text**_ был добавлен как более читаемый псевдоним для _**universal\_newlines**_.

Если задано, _**startupinfo**_ будет объектом STARTUPINFO, который передается базовой функции `CreateProcess`. _**creationflags**_, если задан, может быть одним или несколькими из следующих флагов:

> * CREATE\_NEW\_CONSOLE
> * CREATE\_NEW\_PROCESS\_GROUP
> * ABOVE\_NORMAL\_PRIORITY\_CLASS
> * BELOW\_NORMAL\_PRIORITY\_CLASS
> * HIGH\_PRIORITY\_CLASS
> * IDLE\_PRIORITY\_CLASS
> * NORMAL\_PRIORITY\_CLASS
> * REALTIME\_PRIORITY\_CLASS
> * CREATE\_NO\_WINDOW
> * DETACHED\_PROCESS
> * CREATE\_DEFAULT\_ERROR\_MODE
> * CREATE\_BREAKAWAY\_FROM\_JOB

Объекты **Popen** поддерживаются как диспетчеры контекста с помощью оператора with: при выходе стандартные файловые дескрипторы закрываются, и процесс ожидает.

```python
with Popen(["ifconfig"], stdout=PIPE) as proc:
    log.write(proc.stdout.read())
```

**Popen** и другие функции в этом модуле, которые его используют, вызывают события аудита `subprocess.Popen` с аргументами `executable`, `args`, `cwd` и `env`. Значение _**args**_ может быть одной строкой или списком строк, в зависимости от платформы.

_Изменено в версии 3.2:_ Добавлена поддержка диспетчера контекста.

_Изменено в версии 3.6:_ деструктор **Popen** теперь выдает предупреждение ResourceWarning, если дочерний процесс все еще выполняется.

_Изменено в версии 3.8:_ **Popen** может использовать os.posix\_spawn \(\) в некоторых случаях для повышения производительности. В подсистеме Windows для Linux и пользовательской эмуляции QEMU конструктор **Popen**, использующий os.posix\_spawn \(\), больше не генерирует исключение при таких ошибках, как отсутствие программы, но дочерний процесс завершается с ошибкой с ненулевым кодом возврата.

