# subprocess.Popen

#### _class_ subprocess.Popen \( _args_, _bufsize=-1_, _executable=None_, _stdin=None_, _stdout=None_, _stderr=None_, _preexec\_fn=None_, _close\_fds=True_, _shell=False_, _cwd=None_, _env=None_, _universal\_newlines=None_, _startupinfo=None_, _creationflags=0_, _restore\_signals=True_, _start\_new\_session=False_, _pass\_fds=\(\)_, _\*_, _encoding=None_, _errors=None_, _text=None_ \)

Выполняет дочернюю программу в новом процессе. В POSIX класс использует поведение, подобное os.execvp \(\), для выполнения дочерней программы. В Windows класс использует функцию Windows CreateProcess \(\). Аргументы класса **Popen** следующие:

_**args**_ должен быть последовательностью аргументов программы или отдельной строкой или объектом, подобным пути \(_path-like object_ \). По умолчанию программа для выполнения является первым элементом в _**args**_, если args является последовательностью. Если _**args**_ является строкой, интерпретация зависит от платформы и описана ниже. См. аргументы _**shell**_ и _**executable**_, чтобы узнать о дополнительных отличиях от поведения по умолчанию. Если не указано иное, рекомендуется передавать аргументы в виде последовательности.

Пример передачи некоторых аргументов внешней программе в виде последовательности:

```python
Popen(["/usr/bin/git", "commit", "-m", "Fixes a bug."])
```

В POSIX, если _**args**_ является строкой, строка интерпретируется как имя или путь выполняемой программы. Однако это можно сделать, только если не передать аргументы программе.

{% hint style="info" %}
**Примечание:** Может быть неочевидно, как разбить команду оболочки на последовательность аргументов, особенно в сложных случаях. `shlex.split ()` может проиллюстрировать, как определить правильную токенизацию для _**args**_:

```python
>>> import shlex, subprocess
>>> command_line = input()
/bin/vikings -input eggs.txt -output "spam spam.txt" -cmd "echo '$MONEY'"
>>> args = shlex.split(command_line)
>>> print(args)
['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', "echo '$MONEY'"]
>>> p = subprocess.Popen(args) # Success!
```

Обратите внимание, в частности, что параметры \(такие как _-input_ \) и аргументы \(например, _egg.txt_ \), разделенные пробелом в оболочке, помещаются в отдельные элементы списка, в то время как аргументы, требующие кавычек или экранирования обратной косой черты при использовании в оболочке \(например, имена файлов, содержащие пробелы или показанную выше команду _echo_ \) являются отдельными элементами списка.
{% endhint %}

В Windows, если _**args**_ является последовательностью, она будет преобразована в строку способом, описанным в разделе «Преобразование последовательности аргументов в строку в Windows». Это связано с тем, что базовый `CreateProcess ()` работает со строками.

_Изменено в версии 3.6:_ параметр _**args**_ принимает объект, подобный пути \(_path-like object_ \), если оболочка имеет значение `False`, и последовательность, содержащую объекты, подобные пути \(_path-like object_ \), в POSIX.

_Изменено в версии 3.8:_ параметр _**args**_ принимает объект, подобный пути \(_path-like object_ \), если оболочка имеет значение `False`, и последовательность, содержащую байты и объекты, подобные пути \(_path-like object_ \), в Windows.

Аргумент _**shell**_ \(по умолчанию `False`\) указывает, следует ли использовать оболочку в качестве программы для выполнения. Если _**shell**_ имеет значение `True`, рекомендуется передавать аргументы в виде строки, а не последовательности.

В POSIX с `shell = True` для оболочки по умолчанию используется `/bin/sh`. Если _**args**_ является строкой, строка указывает команду, выполняемую через оболочку. Это означает, что строка должна быть отформатирована точно так же, как при вводе в приглашении оболочки. Это включает, например, кавычки или обратную косую черту, экранирующие имена файлов с пробелами. Если _**args**_ представляет собой последовательность, первый элемент определяет командную строку, а любые дополнительные элементы будут обрабатываться как дополнительные аргументы самой оболочки. То есть **Popen** выполняет эквивалент:

```python
Popen(['/bin/sh', '-c', args[0], args[1], ...])
```

В Windows с `shell = True` переменная среды COMSPEC указывает оболочку по умолчанию. Единственный раз, когда вам нужно указать `shell = True` в Windows, - это когда команда, которую вы хотите выполнить, встроена в оболочку \(например, dir или copy\). `shell = True` не требуется для запуска командного файла или исполняемого файла на основе консоли.

{% hint style="info" %}
**Примечание:** прочтите раздел «Вопросы безопасности» перед использованием `shell = True`.
{% endhint %}

_**bufsize**_ будет предоставлен в качестве соответствующего аргумента функции open \(\) при создании файловых объектов stdin/stdout/stderr pipe:

* **0** - означает небуферизованный \(чтение и запись являются одним системным вызовом и могут возвращаться коротко\)
* **1** - означает буферизацию строки \(можно использовать, только если `universal_newlines = True`, т.е. в текстовом режиме\)
* любое другое положительное значение означает использование буфера примерно такого размера
* отрицательный _**bufsize**_ \(по умолчанию\) означает, что будет использоваться системное значение по умолчанию io.DEFAULT\_BUFFER\_SIZE

_Изменено в версии 3.3.1:_ теперь _**bufsize**_ по умолчанию равен **-1**, чтобы по умолчанию включить буферизацию в соответствии с поведением, ожидаемым большинством кода. В версиях, предшествующих Python 3.2.4 и 3.3.1, по умолчанию было неправильно установлено значение 0, которое не буферизовалось и позволяло короткие чтения. Это было непреднамеренно и не соответствовало поведению Python 2, как ожидалось в большинстве программ.

