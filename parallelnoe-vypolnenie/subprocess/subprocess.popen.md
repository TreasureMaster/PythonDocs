# subprocess.Popen

#### _class_ subprocess.Popen \( _args_, _bufsize=-1_, _executable=None_, _stdin=None_, _stdout=None_, _stderr=None_, _preexec\_fn=None_, _close\_fds=True_, _shell=False_, _cwd=None_, _env=None_, _universal\_newlines=None_, _startupinfo=None_, _creationflags=0_, _restore\_signals=True_, _start\_new\_session=False_, _pass\_fds=\(\)_, _\*_, _encoding=None_, _errors=None_, _text=None_ \)

Выполняет дочернюю программу в новом процессе. В POSIX класс использует поведение, подобное os.execvp \(\), для выполнения дочерней программы. В Windows класс использует функцию Windows CreateProcess \(\). Аргументы класса **Popen** следующие:

_**args**_ должен быть последовательностью аргументов программы или отдельной строкой или объектом, подобным пути \(_path-like object_ \). По умолчанию программа для выполнения является первым элементом в _**args**_, если args является последовательностью. Если _**args**_ является строкой, интерпретация зависит от платформы и описана ниже. См. аргументы _**shell**_ и _**executable**_, чтобы узнать о дополнительных отличиях от поведения по умолчанию. Если не указано иное, рекомендуется передавать аргументы в виде последовательности.

Пример передачи некоторых аргументов внешней программе в виде последовательности:

```python
Popen(["/usr/bin/git", "commit", "-m", "Fixes a bug."])
```

В POSIX, если _**args**_ является строкой, строка интерпретируется как имя или путь выполняемой программы. Однако это можно сделать, только если не передать аргументы программе.

{% hint style="info" %}
**Примечание:** Может быть неочевидно, как разбить команду оболочки на последовательность аргументов, особенно в сложных случаях. `shlex.split ()` может проиллюстрировать, как определить правильную токенизацию для _**args**_:

```python
>>> import shlex, subprocess
>>> command_line = input()
/bin/vikings -input eggs.txt -output "spam spam.txt" -cmd "echo '$MONEY'"
>>> args = shlex.split(command_line)
>>> print(args)
['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', "echo '$MONEY'"]
>>> p = subprocess.Popen(args) # Success!
```

Обратите внимание, в частности, что параметры \(такие как _-input_ \) и аргументы \(например, _egg.txt_ \), разделенные пробелом в оболочке, помещаются в отдельные элементы списка, в то время как аргументы, требующие кавычек или экранирования обратной косой черты при использовании в оболочке \(например, имена файлов, содержащие пробелы или показанную выше команду _echo_ \) являются отдельными элементами списка.
{% endhint %}

В Windows, если _**args**_ является последовательностью, она будет преобразована в строку способом, описанным в разделе «Преобразование последовательности аргументов в строку в Windows». Это связано с тем, что базовый `CreateProcess ()` работает со строками.

_Изменено в версии 3.6:_ параметр _**args**_ принимает объект, подобный пути \(_path-like object_ \), если оболочка имеет значение `False`, и последовательность, содержащую объекты, подобные пути \(_path-like object_ \), в POSIX.

_Изменено в версии 3.8:_ параметр _**args**_ принимает объект, подобный пути \(_path-like object_ \), если оболочка имеет значение `False`, и последовательность, содержащую байты и объекты, подобные пути \(_path-like object_ \), в Windows.

